pico-8 cartridge // http://www.pico-8.com
version 33
__lua__
function has_value(t,v) -- table,value
 for i,val in ipairs(t) do
  if v==val then
   return true
  end
 end
 return false
end

function calc_d_lut()
    local d_lut={}
    for tx=0,7 do
        d_lut[tx] = {}
        for ty=0,7 do
            d_lut[tx][ty]=sqrt(tx*tx+ty*ty)
        end
    end
    return d_lut
end

d_lut=calc_d_lut()

function _init()
end

// c-style ternary operator
function t(cond,a,b)
	if cond==0 or cond==nil or
	not cond then
		return b
	else
		return a
	end
end

// c-style not.
function neg(a)
	return t(a,0,1)
end

// clamp (value, min, max)
function cla(x,mn,mx)
 return t(x>mx,mx,t(x<mn,mn,x))
end

-- random integer	
function irnd(n)
	return flr(rnd(n))
end

-- is n odd?
function odd(n)
	return ((flr(n)&0x01)==0x01)
end

function rect2(x,y,w,h,c)
	rect(x,y,x+w,y+h,c)
end

function rectfill2(x,y,w,h,c)
	rectfill(x,y,x+w,y+h,c)
end


n=1 -- number of periods within circle radius
sw=128 -- screen width
sw_h=sw/2 -- screen width half
sh=sw -- screen height
sh_h=sh/2 -- screen height half
ts=8 -- tile side
sw_t=sw/ts -- screen width, in tiles
sh_t=sh/ts -- screen height, in tiles
period=240 -- effect period, in frames
r=sw_t -- circle radius

timer=0
function _update()
    if timer==period-1 then
        timer=0
    else
        timer+=1
    end
end

-- starting point: 20% cpu usage
-- no flipping: 18%
-- distance lut: 17%


bayer_4x4_fillp_lut={[0]=0b0000000000000000.010,0b1000000000000000.010,0b1000000000100000.010,0b1010000000100000.010,0b1010000010100000.010,0b1010010010100000.010,0b1010010010100001.010,0b1010010110100001.010,0b1010010110100101.010,0b1110010110100101.010,0b1110010110110101.010,0b1111010110110101.010,0b1111010111110101.010,0b1111110111110101.010,0b1111110111110111.010,0b1111111111110111.010,0b1111111111111111.010}
function _draw()
    cls()
    for tx=0,sw_t/2-1 do
        px=tx*ts
        for ty=0,sh_t/2-1 do
            py=ty*ts
            local d=sqrt(tx*tx+ty*ty) -- tried putting this in a lut, but no perf gains
            local intensity=17/2*(1.0+sin(d*n/r-timer/period))
            if tx==0 and ty==0 then
                printh(intensity)
            end
            fillp(bayer_4x4_fillp_lut[cla(flr(intensity),0,16)])
            spr(32,     px+sw_h,    py+sh_h) -- DR
            spr(32,     px+sw_h,-ts-py+sh_h) -- UR
            spr(32, -ts-px+sw_h,    py+sh_h) -- DL
            spr(32, -ts-px+sw_h,-ts-py+sh_h) -- UL
        end
    end
end

-- lo que importa no es tener uno que sea del 50%, sino uno de 0.0, otro de 1.0, y los demas uniformemente distribuidos

__gfx__
00000000000000000000100000101000001010001010100010101000101010101010101010101010101010111011101111111011111111111111111111111111
00000000000000000000000000000001000000010000010100010101010101010101010101010101010101010101010101010101010111010111110111111111
00000000000000000010000000100000101010001010100010101010101010101010101010101110111011101111111011111111111111111111111111111111
00000000000000010000000100000001000000010100000101010001010100010101010101010101010101010101010101010101011101011111110111111111
00000000100000001000000010000000100000101000101010001010100010101010101010101010101010101010101010111010101111101111111111111111
00000000000000000000010000010100000101000001010001010101010101010101010101110101011101110111111111111111111111111111111111111111
00000000000000000000000010000000101000001010000010100000101010101010101010101010101010101010101010101010101110101011101011111111
00000000000100010001000100010001000101010001010100010101010101010101010101010101110101011101110111011111111111111111111111111111
00000000100010001000100010001000101010101010101010101010101010100000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000101010101010101010101010000000000000000000000000000000000000000000000000000000000000000
00000000000000000010001010101010101010101010101010101010101010100000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000010001000100010000000000000000000000000000000000000000000000000000000000000000
00000000100010001000100010001000101010101010101010101010101010100000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000101010101010101010101010000000000000000000000000000000000000000000000000000000000000000
00000000000000000010001010101010101010101010101010101010101010100000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000010001000100010000000000000000000000000000000000000000000000000000000000000000
11111111bbbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
11111111bbbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
11111111bbbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
11111111bbbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
11111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
11111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
11111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
11111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
